{"version":3,"file":"withStickerIcon.js","sourceRoot":"","sources":["../src/withStickerIcon.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,mBAAmB,CAAC;AACvD,OAAO,EAAE,MAAM,IAAI,CAAC;AACpB,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAwB5B,MAAM,gBAAgB,GAAG,oBAAoB,CAAC;AAE9C,8EAA8E;AAC9E,MAAM,aAAa,GAOb;IACJ;QACE,KAAK,EAAE,QAAQ;QACf,KAAK,EAAE;YACL;gBACE,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;aACf;YACD;gBACE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;gBACd,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;aACf;SACF;KACF;IACD;QACE,KAAK,EAAE,MAAM;QACb,KAAK,EAAE;YACL;gBACE,IAAI,EAAE,EAAE;gBACR,MAAM,EAAE,CAAC,CAAC,CAAC;aACZ;YACD;gBACE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;gBACd,MAAM,EAAE,CAAC,CAAC,CAAC;aACZ;YACD;gBACE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;gBACd,MAAM,EAAE,CAAC,CAAC,CAAC;aACZ;SACF;KACF;IACD;QACE,KAAK,EAAE,WAAW;QAClB,KAAK,EAAE;YACL;gBACE,QAAQ,EAAE,KAAK;gBAEf,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;gBACd,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;aACf;YACD;gBACE,QAAQ,EAAE,KAAK;gBAEf,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;gBACd,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;aACf;SACF;KACF;IACD;QACE,KAAK,EAAE,eAAe;QACtB,KAAK,EAAE;YACL;gBACE,QAAQ,EAAE,KAAK;gBAEf,IAAI,EAAE,IAAI;gBACV,MAAM,EAAE,CAAC,CAAC,CAAC;aACZ;YACD;gBACE,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC;gBACjB,MAAM,EAAE,CAAC,CAAC,CAAC;aACZ;SACF;KACF;CACF,CAAC;AAEF,MAAM,CAAC,KAAK,UAAU,0BAA0B,CAC9C,WAAmB,EACnB,IAAY,EACZ,SAAiB;IAEjB,4DAA4D;IAC5D,EAAE,CAAC,SAAS,CAAC,SAAS,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IAE7C,gEAAgE;IAChE,MAAM,UAAU,GAAwB,EAAE,CAAC;IAE3C,yFAAyF;IACzF,MAAM,cAAc,GAA4B,EAAE,CAAC;IAEnD,KAAK,MAAM,QAAQ,IAAI,aAAa,EAAE;QACpC,0DAA0D;QAC1D,KAAK,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,IAAI,QAAQ,CAAC,KAAK,EAAE;YACtD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;gBAC1B,2DAA2D;gBAC3D,MAAM,QAAQ,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAC/D,2DAA2D;gBAC3D,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAClE,IAAI,CAAC,CAAC,QAAQ,IAAI,cAAc,CAAC,EAAE;oBACjC,MAAM,WAAW,GAAG,KAAK,GAAG,KAAK,CAAC;oBAClC,MAAM,WAAW,GAAG,MAAM,GAAG,KAAK,CAAC;oBAEnC,oGAAoG;oBACpG,6EAA6E;oBAC7E,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,kBAAkB,CACzC,EAAE,WAAW,EAAE,SAAS,EAAE,gBAAgB,EAAE,EAC5C;wBACE,GAAG,EAAE,IAAI;wBACT,IAAI,EAAE,QAAQ;wBACd,KAAK,EAAE,WAAW;wBAClB,MAAM,EAAE,WAAW;wBACnB,kBAAkB,EAAE,IAAI;wBACxB,sEAAsE;wBACtE,UAAU,EAAE,OAAO;wBACnB,yEAAyE;wBACzE,kEAAkE;wBAClE,eAAe,EAAE,SAAS;qBAC3B,CACF,CAAC;oBACF,yCAAyC;oBACzC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;oBAC5C,MAAM,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;oBAC/C,0EAA0E;oBAC1E,cAAc,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;iBACjC;gBACD,UAAU,CAAC,IAAI,CAAC;oBACd,KAAK,EAAE,QAAQ,CAAC,KAA+B;oBAC/C,IAAI,EAAE,GAAG,KAAK,IAAI,MAAM,EAAE;oBAC1B,qDAAqD;oBACrD,KAAK,EAAE,GAAG,KAAK,GAAG;oBAClB,QAAQ;iBACT,CAAC,CAAC;gBACH,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACjB,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;iBAC5D;aACF;SACF;KACF;IAED,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,SAAS,gBAAgB,CACvB,IAA+B,EAC/B,KAAa,EACb,KAAa;IAEb,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAClE,OAAO,YAAY,KAAK,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,OAAO,CAAC;AAC9D,CAAC","sourcesContent":["import { generateImageAsync } from \"@expo/image-utils\";\nimport fs from \"fs\";\nimport { join } from \"path\";\n\nexport type ContentsJsonImageIdiom =\n  | \"iphone\"\n  | \"ipad\"\n  | \"ios-marketing\"\n  | \"universal\";\n\nexport type ContentsJsonImageAppearance = {\n  appearance: \"luminosity\";\n  value: \"dark\";\n};\n\nexport type ContentsJsonImageScale = \"1x\" | \"2x\" | \"3x\";\n\nexport interface ContentsJsonImage {\n  appearances?: ContentsJsonImageAppearance[];\n  idiom: ContentsJsonImageIdiom;\n  size?: string;\n  scale: ContentsJsonImageScale;\n  filename?: string;\n  platform?: string;\n}\n\nconst IMAGE_CACHE_NAME = \"ios-stickers-icons\";\n\n// Hard-coding seemed like the clearest and safest way to implement the sizes.\nconst ICON_CONTENTS: {\n  idiom: ContentsJsonImageIdiom;\n  sizes: {\n    size: number | [number, number];\n    platform?: string;\n    scales: (1 | 2 | 3)[];\n  }[];\n}[] = [\n  {\n    idiom: \"iphone\",\n    sizes: [\n      {\n        size: 29,\n        scales: [2, 3],\n      },\n      {\n        size: [60, 45],\n        scales: [2, 3],\n      },\n    ],\n  },\n  {\n    idiom: \"ipad\",\n    sizes: [\n      {\n        size: 29,\n        scales: [2],\n      },\n      {\n        size: [67, 50],\n        scales: [2],\n      },\n      {\n        size: [74, 55],\n        scales: [2],\n      },\n    ],\n  },\n  {\n    idiom: \"universal\",\n    sizes: [\n      {\n        platform: \"ios\",\n\n        size: [27, 20],\n        scales: [2, 3],\n      },\n      {\n        platform: \"ios\",\n\n        size: [32, 24],\n        scales: [2, 3],\n      },\n    ],\n  },\n  {\n    idiom: \"ios-marketing\",\n    sizes: [\n      {\n        platform: \"ios\",\n\n        size: 1024,\n        scales: [1],\n      },\n      {\n        size: [1024, 768],\n        scales: [1],\n      },\n    ],\n  },\n];\n\nexport async function generateImessageIconsAsync(\n  projectRoot: string,\n  icon: string,\n  iconsPath: string\n): Promise<ContentsJsonImage[]> {\n  // Ensure the Images.xcassets/AppIcon.appiconset path exists\n  fs.mkdirSync(iconsPath, { recursive: true });\n\n  // Store the image JSON data for assigning via the Contents.json\n  const imagesJson: ContentsJsonImage[] = [];\n\n  // keep track of icons that have been generated so we can reuse them in the Contents.json\n  const generatedIcons: Record<string, boolean> = {};\n\n  for (const platform of ICON_CONTENTS) {\n    // const isMarketing = platform.idiom === 'ios-marketing';\n    for (const { size, scales, ...rest } of platform.sizes) {\n      for (const scale of scales) {\n        // The marketing icon is special because it makes no sense.\n        const filename = getAppleIconName(size, scale, platform.idiom);\n        // Only create an image that hasn't already been generated.\n        const [width, height] = Array.isArray(size) ? size : [size, size];\n        if (!(filename in generatedIcons)) {\n          const iconWSizePx = width * scale;\n          const iconHSizePx = height * scale;\n\n          // Using this method will cache the images in `.expo` based on the properties used to generate them.\n          // this method also supports remote URLs and using the global sharp instance.\n          const { source } = await generateImageAsync(\n            { projectRoot, cacheType: IMAGE_CACHE_NAME },\n            {\n              src: icon,\n              name: filename,\n              width: iconWSizePx,\n              height: iconHSizePx,\n              removeTransparency: true,\n              // The icon should be square, but if it's not then it will be cropped.\n              resizeMode: \"cover\",\n              // Force the background color to solid white to prevent any transparency.\n              // TODO: Maybe use a more adaptive option based on the icon color?\n              backgroundColor: \"#ffffff\",\n            }\n          );\n          // Write image buffer to the file system.\n          const assetPath = join(iconsPath, filename);\n          await fs.promises.writeFile(assetPath, source);\n          // Save a reference to the generated image so we don't create a duplicate.\n          generatedIcons[filename] = true;\n        }\n        imagesJson.push({\n          idiom: platform.idiom as ContentsJsonImageIdiom,\n          size: `${width}x${height}`,\n          // @ts-ignore: template types not supported in TS yet\n          scale: `${scale}x`,\n          filename,\n        });\n        if (rest.platform) {\n          imagesJson[imagesJson.length - 1].platform = rest.platform;\n        }\n      }\n    }\n  }\n\n  return imagesJson;\n}\n\nfunction getAppleIconName(\n  size: number | [number, number],\n  scale: number,\n  idiom: string\n) {\n  const [width, height] = Array.isArray(size) ? size : [size, size];\n  return `App-Icon-${idiom}-${width}x${height}@${scale}x.png`;\n}\n"]}